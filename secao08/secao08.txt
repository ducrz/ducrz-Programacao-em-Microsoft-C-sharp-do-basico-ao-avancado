Seção 08: Orientação a Objetos com C# - Parte 2

43. O que vamos aprender nesta seção?


44. Herança

Herança é uma característica que permite que você estenda uma classe, ou seja,
você pode criar novas classes e fazer com que essas classes herdem as características da classe origem.

Então você pode acrescentar novas propriedades e métodos a estas classes.

Uma classe que herda as características de outra é chamada de classe-filha ou subclasse.

A classe que foi herdada é chamada de classe-Pai, classe base ou superclasse.


Como fazer em C#

No C# usamos a declaração ":" (dois pontos) para implementar a herança. O C# suporta a herança múltipla, assim uma classe
derivada pode ter uma ou mais classes base.


class Veiculo{
	public void Alugar(){

	}
	public void RegrasDeRetorno{

	}

}

//Classe derivada

class Carro : Veiculo{

	public void Promocao(){

	}
}

Herança e Construtores

Caso a classe base tiver construtor e a filha também, é possível inicializar a classe base.



//Classe base
class Veiculo{

	protected string Marca;
	protected string Modelo;
	private string Placa;

	public Veiculo(string Marca, string Modelo){
		this.Marca = Marca;
		this.Modelo = Modelo;
		this.Placa = "DDD-9999";
	}

	public void Alugar(){

	}
	public void RegrasDeRetorno(){

	}
}


//Class derivada

class Carro : Veiculo {
	public void Promocao(string Marca, string Modelo) : base(Marca, Modelo){

	}
}


Protected

Fica visível apenas para a própria classe (no exemplo veículo) e para as classes derivadas.

Nem sempre é uma boa ideia utilizar Protected porque pode "ferir" o encapsulamento.


Veiculo.cs

Dica: Uso do F12 para ir para onde está definida a propriedade/origem.

Herança evita a duplicação de código, "reutilização de código".




45. Sobrecarga de métodos


Em orientação a objetos, uma sobrecarga refere-se aos métodos de uma classe, sendo que estes podem
ser sobrecarregados em relação aos seus nomes, podendo diversos métodos possuir o mesmo nome,
porém os tipos de dados da lista de parâmetros deve ser divergente.

Ou seja, os métodos têm o mesmo nome mas a sua assinatura difere.


Como fazer em C#


class Carro{

	public void Alugar(){
	
	}
	public void Alugar(DateTime DataInicio){
	
	}
	public void Alugar(int NumeroDeDias){

	}
}


class Carro{

	public Carro(){}
	public Carro(string Modelo){}
	public Carro(string Modelo, string Marca){}

}



46. Sobrescrita de métodos

Sobreescrevendo um método.


Sobrescrita (override), é uma técnica de OOP que permite sobreescrever um comportamento de uma classe base.

Usando override podemos rescrever um método em uma classe derivada para fazer algo diferente do método
sobrescrito da classe base.

Para isto o método da classe base deve ser declarado com a palavra chave virtual.


REGRAS

- Método virtual não pode ser privado;
- As assinaturas dos métodos base e sobrescrito devem ser idênticas;
- O override só funciona em métodos virtuais.

Sobrescrita é um polimorfismo.



Como fazer em C#

class Veiculo{

	public void Alugar(){

	}

	public virtual void RegrasDeRetorno(){

	}

}

class Carro : Veiculo{

	public override void RegrasDeRetorno(){

	}

}




47. Classes abstratas

Uma classe abstrata é um tipo de classe que serve de base para a criação de outras classes.

Existem diferenças para classes normais que servem de base para a criação de objetos.

Classe abstrata é utilizada para a construção de outras classes.
Classes normais são utilizadas para construção de objetos.

Uma classe abstrata representa um ideal, algo abstrato, uma ideia que não tem forma.



Regras

- Apenas podem ser herdadas por outras classes;
- Não podem ser instanciadas;
- Podem ter implementações de métodos completos;
- Podem conter apenas a assinatura de um futuro método.



Como Fazer isso em C#

Implementa-se utilizando a palavra chave abstract:

abstract public class Veiculo{

	public void Alugar(){

		Console.WriteLine("Este carro foi alugado!");
	}

	abstract public void RetornoVeiculo();


}



Criando uma classe que herda de veículo:

public class Carro : Veiculo{

	public override void RetornoVeiculo(){

		Console.WriteLine("Carro Retornado");
	}

}

É também necessário sobrescrever o método que foi herdado da classe abstrata e que não tem implementação.




48. Interfaces e o Polimorfismo

Interfaces

Interface é um contrato entre a classe e o mundo externo. Quando uma classe implementa uma interface,
ela está comprometida a fornecer o comportamento publicado pela interface.



Uma classe pode implementar inúmeras interfaces.



POLIMORFISMO


Uma funcionalidade oferecida pela OO é o polimorfismo, que significa "muitas formas".

O Polimorfismo permite, em uma das suas metodologias de aplicação, que diferentes classes tenham métodos
com a mesma assinatura (mesmo contrato), porém estes métodos (em suas respectivas classes) podem possuir comportamentos
diferentes, de acordo com a necessidade de cada classe que o implementa.


A implemetação do polimorfismo pode ser realizada fazendo uso de interfaces ou classes abstratas,
onde ocorrem apenas a implementação das assinaturas dos métodos, ou seja, do contrato.

Desta forma o comportamento deve ser implementado nas classes concretas que implementam as interfaces ou
estendem as classes abstratas.

No polimorfismo, as assinaturas de métodos descritas nos contratos devem ser obrigatoriamente implementadas
na classe que as herda.



Como fazer em C#


public interface IVeiculo{

	void Alugar();
	void RetornoVeiculo();

}

Não existe a necessidade de adicionar modificadores de acesso.



public class Carro : IVeiculo{

	public void Alugar(){

		Console.WriteLine("Este carro foi alugado.");
	}
	
	public void RetornoVeiculo(){

		Console.WriteLine("Carro Retornado");
	}

}

Não é necessário utilizar a palavra chave override.


Folder Interfaces

Add > New Interface > ICarro.cs




Classes Abstratas vs Interfaces


- Classes podem herdar apenas de uma classe abstrata.
- Classes podem implementar várias interfaces.
- Interfaces são úteis na inversão de controle, injeção de dependência e ajudam na testabilidade da classe.


Pensar bem nestes pontos quando for decidir entre usar classes abstratas ou interfaces.




49. Atributos e métodos estáticos


Métodos e atributos static


Permitem que um método possa ser invocado sem precisar criar uma instância de classe.


O modificador static permite indicar que o método pertence a classe a não as suas instâncias.

"Auto invocável"



Como fazer em C#


public class CarroDadosBasicos{

	public static void Descricao(){

		Console.WriteLine("Este é um método estático.");
	}

}

Da mesma forma é possível ter propriedades estáticas.


public class CarroDadosBasicos{

	public static string NumeroRodas = "4";
	public static string NumeroBaterias { get { return "1";} }

	public static void Descricao(){
	
		Console.WriteLine("Este é um método estático com uma descrição do carro");
	}


}


A primeira declaração é um tipo "campo" ou "field".

A segunda declaração é uma propriedade.

Folder > ClassesEstaticas





50. Criando e manipulando listas de objetos

A coleção List(T) representa uma coleção de objetos tipados, a qual é altamente otimizada oferecendo
um bom desempenho e pode ser acessada usando índice.

Esta classe fornece métodos para percorrer, filtrar, ordenar, procurar e manipular coleções.
A versão não genérica seria a classe ArrayList.


Como fazer em C#

Lista de Objetos

Se eu tenho um objeto Carro, eu posso criar uma lista de objetos da seguinte forma:


List<Carro> pLista = new List<Carro>();

pLista.Add(new Carro("Volkswagem", "Nivus"));
pLista.Add(new Carro("Honda","HRV"));

//Para remover um item

pLista.Remove(Carro);

//Encontrar um carro
pLista.Find(Carro);


51. Introdução a instruções lambda

Uma expressão lambda é uma maneira conveniente de definir uma função anônima (sem nome)
que pode ser transmitida como uma variável ou como um parâmetro para uma chamada de método.
Muitos métodos LINQ usam uma função (chamada delegada) como parâmetro.

O C# 3.0 (.NET 3.5) introduziu a expressão lambda junto com o LINQ. A expressão lambda  é uma maneira
mais curta de representar o método anônimo usando alguma sintaxe especial.



Exemplo de expressão Lambda


Func<int, int> MultiplicarPor5 = num => num *5;
//Return 35
int result = MultiplicarPor5(7);


A expressão num => num * 5 é a lambda.

O operador => é o operador lambda.

O "num" é um parâmetro de entrada para a função anônima.

Logo quando a função MultiplicarPor5 for chamada o resultado é 7*5 = 35.


Parâmetros

O Parâmetro "num" não especifica explicitamente um tipo de dados.
O compilador infere os tipos de dados dos parâmetros de expressão lambda do contexto.

Nesse caso, o contexto é que a expressão lambda é armazenada em uma variável do tipo Func <int, int>.
Isso significa que ele pega um parâmetro int e retorna um resultado int.


É possível passar mais de um parâmetro para uma Lambda:


Func<int, int, int> Multiplicar = (a,b) => a*b;
//Return 35

int result = Multiplicar(7,5);



LINQ

Language-Integrated Query, é uma tecnologia que permite integrar consultar diretamente dentro da linguagem C#.

Segundo a Microsoft, a família de tecnologias LINQ fornece uma experiência de consulta consistente para objetos
(LINQ to Objects), banco de dados relacionais (LINQ to SQL) e XML (LINQ to XML).



LINQ

As expressões de consulta (query expressions) são escritas em uma sintaxe de consulta declarativa.

Usando a sintaxe de consulta, você pode executar operações de filtragem, agrupamento, seleção e etc, em fontes
de dados com o mínimo de código.

São usados os mesmos padrões básicos de expressões de consultas para consultar e transformar dados
em banco de dados SQL, ADO .NET Datasets, documentos e fluxos SML e coleções .NET.




int[] notas = new int[] {97, 92, 81, 60};

IEnumerable<int> notasQuery =
from nota in notas
where nota > 80
select nota;



Lambda Expressions e Linq

Normalmente a expressão lambda pode ser usada com uma consulta LINQ dentro de um método que tenha suporte.

A classe estática enumerável inclui o método de extensão Where para IEnumerable<T>
que aceita Func<TSource, bool>.

Portanto, o método de extensão Where() da coleção IEnumerable<Carro> é necessário para
passar uma Func<Carro, bool>.


int[] notas = {90, 71, 82, 93, 75, 82};

int contagem = notas.Where(n => n > 80).Count();


Como fazer em C#

//Lista de Carros
IList<Carro> listaCarros = new List<Carro>() { };

//Lambda
Func<Carro, bool> filtro = s => s.Cor == "Verde";


//Linq com lambda usada no método Where
var listaFiltrada = listaCarros.Where(filtro).ToList();





52. Recapitulando

Herança.
Sobrecarga de métodos.
Sobreescrita de métodos.
Classes Abstratas.
Interfaces e Polimorfismo.
Atributos e métodos estáticos.
Criando e manipulando listas de objetos.
Introdução a instruções Lambda.





