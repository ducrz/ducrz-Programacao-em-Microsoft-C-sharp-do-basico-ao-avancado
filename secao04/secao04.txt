Seção 4: C# Intermediário


Segundo Projeto.


20. O que vamos aprender nesta seção?



21. Conversão entre tipos de dados


Conversão implícita e explícita.

Conversões implícitas acontecem automaticamente, o compilador tenta "adivinhar" o tipo e realizar uma conversão.

Nas conversões explícitas é o programador que indica ao compilador qual tipo de conversão será realizada.

Um dos tipos de conversões mais frequentes é a conversão em String.

Datetime data = DateTime.Now

Console.Write(data.ToString());



Exemplo de conversão implícita:


int i =5;
DateTime data = DateTime.Now;
Console.WriteLine(i);
Console.WriteLine(data);


Outro exemplo(neste caso não funciona):

int i = 5;

DateTime data = DateTime.Now;

Console.WriteLine(i+data);


Neste caso é necessário a conversão explícita:

int i=5;
DateTime data = DateTime.Now;

Console.WriteLine(i.ToString() + data);

Agora o compilador sabe que o que queremos é mostrar os valores como string.
O valor de "i" é convertido explicitamente, já o "data" é convertido implicitamente pelo compilador.




22. Operações úteis em strings


Manipulação de strings, ou seja, operações de formatação e de dados.

Utilidade:

- Para criar um "parser" de um log;
- Manipular informações armazenadas em um banco de dados;
= Manipular ou criar strings em formato json;
- Manipular formato de data/hora
- Demais operações necessárias.


Algumas das funções com strings suportadas pelo C#:

SubString
Trim
TrimLeft
TrimRigth
Length
Replace
Constains
IndexOf



Concatenaço:

Concat(String,String)

+
StringBuilder

StringBuilder sb = new StringBuilder();
sb.Append("texto 1");
sb.Append("texto 2");
Console.WriteLine("Resultado "+sb);



Concatenação String.Format

Permite a criação de uma string baseada em um padrão. Podemos colocar dentro do padrão
da string de formatação alguns tokens que podem ser substituídos por variáveis passadas por
parâmetro no comando format.


string teste = String.Format("Vou colocar o {0} aqui.",""Parâmetro");


sTeste = String.Format("Formatação de string com {0} parâmetro.","Agora são {1}. Valor numérico: {2}",
1, Now(), 15.5);


sTeste = String.Format("Custom Format: {0:d/M/yyy HH:mm:ss}",dtHoje);
sTeste = String.Format("Formatação do número inteiro: {0:D}.",iNumero);
sTeste = String.Format("Formatação do número inteiro: {0:D4}.",iNumero);



Formatação:

ToLower
ToUpper
Replace




23. Criando funções em C#


Funções são usadas para:

- Organizar código;
- Evitar duplicação de código;
- Reutilização de código;
- Legibilidade de código;



Estrutura de uma função:

<visibility> <return type> <name>(<parameters>)
{
	<function code>
}

Para utilizar uma função:

MostrarNome();

Exemplo de função MostrarNome():

public void MostrarNome(){

	Console.WriteLine("Meu nome é: Eduardo");
}


Também é possível retornar valores:

public int Somatoria(int numero1, int numero2){

	int resultado = numero1 + numero2;
	return resultado;
}



Funcoes.cs


Comentários em funções.

        ///<Summary>
        ///Esta função soma dois números e retorna o resultado
        ///</Summary>
	///<param name="numero1"> Primeiro Valor inteiro </param>
	///<param name="numero2"> Segundo valor inteiro </param>
	///<returns>Retorna a soma dos números passados por parâmetro.</returns>


24. Aplicações console e debug de aplicações


Como depurar aplicações no Visual Studio:

Iniciar o depurador;
Definir pontos de interrupção na execução.
Navegador pelo código em modo depuração.
Inspecionar o valor de uma variável.



Debug > Start Debugging (F5)

Create Breakpoint (F9).

Pular Método (F10)

Intervir - Entra no método (F11)



25. Manipulando listas, arrays e vetores


Manipulando Arrays

"Conjunto de elementos de um mesmo tipo de dados, onde cada elemento do conjunto é acessado pela posição 
no array que é dada através de um índice(uma sequência de números inteiros). Um array de uma dimensão é também conhecido
como vetor, e, um array de mais de uma dimensão é conhecido como uma matriz."


Declarando Arrays em C#

Na linguagem C# os arrays possuem o índice com base zero, ou seja, o primeiro elemento possui índice zero.

Um array de uma dimensão é declarado informando o tipo de dado do array seguido do nome do array,
lembrando que devemos colocar colchetes [] depois do tipo do array e não após o seu nome.

Ex:

int[] tabela; //CORRETO

int tabela []; //INCORRETO



Em C# o tamanho do array não é parte do seu tipo, isso permite declarar um array e em seguida atribuir
qualquer array de objetos int a ele, sem considerar o seu tamanho:

Ex: int[] numeros; //Array de inteiros de qualquer tamanho

    numeros = new int[10]; //Numeros agora é um array de 10 elementos
    
    numeros = new int[20]; //Números agora é um array de 20 elementos



Além de arrays de uma dimensão, C# suporta os seguintes tipos de arrays:

- Arrays com mais de uma dimensão:

  string[,] names;
  int[,] array = new int[2,2];

- Array-of-arrays(jagged):
  byte[][] resultadps;
  int[][] numArray = new int[][]{new int[] {1,3,5}, new int[]{2,4,6,8,10}}

CRIANDO E INICIALIZANDO UM ARRAY


CRIANDO UM ARRAY

string[] nomes; //array nomes de qualquer tamanho.

DECLARANDO UM ARRAY

nomes = new string[5]; //array de strings de 5 elementos

INICIALIZANDO O ARRAY

nomes[0]="Eduardo";
nomes[1]="Francisco";
nomes[2]="Paulo";
nomes[3]="Pedro";
nomes[4]="Tiago";

Também é possível:

String[] nomes = new string[5]();


Para um array de mais de uma dimensão, a sintaxe usada pode ser:

string[,] names = new string[5,4]; //declara um array bidimensional com 5 linhas e 4 colunas

Outras formas de declarar arrays de uma dimensão:

//Definindo o tamnho e o operador new
int[] numeros = new int[5]{1,2,3,4,5}
string[] nomes = new string[3]{"Mac","Jessica","MiMi"};


//Omitindo o tamanho do array
int[] numeros = new int[]{1,2,3,4,5};
string[] nomes = new string[]{"Mac","Jessica","MiMi"};

//Omitindo o operador new
int[] numeros = {1,2,3,4,5};
string[] nomes = {"Mac","Jessica","MiMi"};



Mais de uma dimensão

//Definindo o tamanho e o operador new
int[,] numeros = new int[3,2]{{1,2},{3,4},{5,6};
string[,] amigos = new string[2,2]{{"Mac","Jan"},{"Mimi","Jeff"}};


//Omitindo o tamanho do array
int[,] numeros = new int[,]{1,2},{3,4},{5,6}};


//Omitindo o operador new

int[,] numeros = {{1,2},{3,4},{5,6}};
string[,] amigos = {{"Mac","Jan"},{"Mimi","Jeff"}};


Arrays de Arrays (jagged arrays)

//Definindo o tamanho e o operador new
int[][] numeros = new int[2][]{new int[]{2,3,4}, new int[]{5,6,7,8,9}};

//Omitindo o tamanho do array
int[][] numeros = new int[][]{new int[]{2,3,4}, new int[]{5,6,7,8,9}};

//ou
int[][] numeros = { new int[]{2,3,4}, new int[]{5,6,7,8,9}};




Percorrendo arrays

WHILE

int i=0;

while( i < 5){

	Console.WriteLine(i);
	i++;
}



ForEach

É uma estrutura de repetição muito útil para iterar array e listas.

string[] nomews = new string[]{"Pablo","Vilma"};

foreach(string nome in nomes){

	Console.WriteLine(nome);
}

Para cada nome no array nomes.


foreach(string nome in nomes)



break


string [] nomes = new string[]{"Pablo","Vilma","Pedro"};

foreach( string nome in nomes){

	Console.WriteLine(nome);
	if(nome == "Vilma")
		break;
}


Projeto Arrays Listas Vetores



Em C# arrays são objetos.

A classe System.Array é a classe abstrata que é a base para todos os tipos de arrays.

A classe Array tem propriedades e métodos para manipular arrays. Os mais relevantes:



PROPRIEDADES

IsFixedSize. Retorna um valor indicando se um array possui um tamanho fixo ou não.

IsReadOnly. Retorna um valor indicando se um array é somente leitura ou não.

IsSynchronized. Retorna um valor que indica se o acesso a um array é thread-safe ou não.

Length. Retorna o número total de itens em todas as dimesões de um array;

Rank. Retorna o número de dimensões de um array.

SyncRoot. Retorna um objeto que pode ser usado para sincronizar o acesso a um array.



MÉTODOS

BynarySearch: Procura em um array unidimensional por um valor usando o algoritmo de busca binário.

Clear. Remove todos os itens de um array e define um intervalo de itens no array com valor zero.

Clone. Cria uma cópia do Array.

Copy. Copia uma seção de um array para outro array e realiza a conversão de tipos e boxing requeridas.

CopyTo. Copia todos os elementos do array unidimensional atual para o array unidimensional especificado
iniciando no índice de destino especificado do array.

CreateInstance. Inicializa uma nova instância da classe array;

GetEnumerator. Retorna um IEnumerator para o array.

GetLength. Retorna o número de itens de um array.

GetLowerBound. Retorna o primeiro item de um array;

GetUpperBound. Retorna o último item de um Array.

GetValue. Retorna o valor do item especificado no Array.

IndexOf. Retorna o índice da primeira ocorrência de um valor em um array de uma dimensão ou em uma porção do array.

Reverse. Reverte a ordem de um item em um array de uma dimensão ou parte do array.

SetValue. Define o item especificado em um array atual para o valor definido.

Sort. Ordena os itens de um array.




Realizando uma busca binária no Array

object oCor = "verde";

int retorno = Array.BinarySearch(Cores, oCor);
if(retorno >= 0)
	Console.WriteLine("Índice do item "+retorno.ToString());
else
	Console.WriteLine("Item não localizado");


Obtendo o índice de um item do Array

int ind = Array.IndexOf(Cores,"verde");

Console.WriteLine("O Índice do item 'verde' é "+ind);




26. Tratamento de erros

Tratamento de Exceções

Uma exceção não é necessariamente um erro, é uma exceção, um caminho dentro da lógica do programa
onde algo inesperado aconteceu.

Essas exceções precisam ser tratadas para evitar falhas no programa.

O C# fornece suporte interno para lidar com exceções usando o try, catch e finally.


Para tratar exceções no C#, coloca-se o código "cercado" por um bloco try-catch.

As declarações de variáveis devem sempre ficar fora do bloco try, para que possam ser acessadas
nos blocos catch e finally.

O bloco try simplesmente informa ao compilador para monitorar o código em busca de uma exceção.

A exceção gerada no bloco try deve ser tratada usando o bloco catch.

Sintaxe:

try{
	//Codigo

}
catch(Exception ex){

	//Tratar Exception
}


O bloco try deve ser seguido por catch ou finally, ou ambos os blocos.

O bloco try sem um catch ou finally dará um erro de tempo de compilação.

A exceção gerada no bloco try pode ser manipulada usando o bloco catch, como mostrado no exemplo acima.

O código no bloco catch será executado apenas quando ocorrer uma exceção.

Um bloco catch múltiplo também pode ser especificado com um tipo de exceção diferente, chamado de
filtro de exceção.

Um bloco de cath múltiplo é útil quando você deseja manipular exceções diferentes de maneiras distintas.



catch(DivideByZeroException ex){
	LogError(ex);
	Console.Write("Impossível dividir por 0.");
}
catch (InvalidOperationException ex){
	LogError(ex);
	Console.Write("Erro, operação inválida.");
}
catch (FormatException ex){
	LogError(ex);
	Console.Write("Erro de Formato Numérico.");
}



FINALLY

O bloco finally deve vir após um bloco try ou catch.

O bloco finally sempre será executado, independente de uma exceção ser lançada ou não.

O bloco finally é geralmente usado para limpeza de código, para descartar objetos não gerenciados, ou seja,
para realizar uma última operação antes de sair do método.



try{

	//Código
}
catch(Exception ex){
	//Tratar Exception
}
finally{

	//Fim
}


Nested try-catch

O C# permite blocos try-catch aninhados.

No bloco try-catch aninhado, uma exceção será capturada no bloco catch que segue o bloco try em 
que ocorreu uma exceção.



Exemplo: Nested try-catch

static void main(string[] args)
{
	Pessoa pessoa = null;

	try{
		try{
			pessoa.nome= "";

		}
		catch{
			Console.WriteLine("Erro ao armazenar o nome.");
		}

	}
	catch{
		Console.WriteLine("Exceção de Sistema.");
	}


}


try 2xtab



27. Recapitulando


Fim Seção 04.
